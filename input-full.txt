By default, output files are written to the current directory.
Once an attacker has credentials for one user, the next stage begins which is lateral traversal. Lateral traversal means movement across a network between systems as the same user identity. The movement is considered lateral, as the attacker has not gained any new, elevated privileges yet. However, the attacker can read the memory on any system which their stolen user identity has administrative privileges. Attackers will then harvest more credentials from these systems, and repeat the process until they gain higher privileges. Given time and persistence, an attacker can often move deeply into a network and gain highly-privileged accounts.
One possible solution to stopping this problem is to simply disable SSO. This solution is viewed as not feasible as users can still be tricked into authenticating, legacy protocols still have credential-equivalent artifacts, and it’s a poor user experience.
A secure OS design necessitates a separation between these.
Admins are human and humans err. Data shows: > 90% of Windows users run as some sort of administrator.
Admin being the ultimate power would mean a total loss of system when a malicious attachment is run by the administrator. Furthermore, we can’t simply assume that administrators are always trusted; what if the administrator is malicious? Administrators should not have total control on the machine. Good examples are games: we want to prevent piracy and cheating. Another example is multi-tenant scenarios. An administrator is not necessarily the only administrator on an OS image. One OS image is not necessarily the only compute domain on a physical machine with VMs.
We can’t simply trust the kernel, either. Because of thousands of system calls and IOCTLs, kernel has a very big attack surface. Furthermore, the diverse ecosystem of many 3rd party drivers with different quality assurance standards makes the security inconsistent.
Past solutions
Microsoft has attempted solving this problem in the past. Authenticode / Kernel Mode Code Signing (KMCS) is designed to put reputation of an authenticated identity on the line. The goal is negatively impacting exploit economics by increasing cost and traceability. The big problem is that strong verification of publishers by CAs is questionable at best and recalls are hard and slow.
Another mechanism is “Protected Process” (PP) / “Protected Process Light” (PPL) that were introduced in
Windows Vista. These technologies isolate sensitive user mode processes from others (including administrators) by preventing injection of threads, memory access and debugging. Since these processes are not protected from kernel, and since kernel cannot be trusted, this mitigation is not enough.
Finally, patch-guard is designed to protect kernel by limiting what kernel mode code can do. However, parts of it are heuristic-based and therefore not failsafe. All these technologies are good for what they are, but they all have an inherent limitation: They are all software based. Ideally, we want to root security on HW.
HW protections
Historically, Intel architecture systems used “rings” to protect various levels of OS. Ring 0 commanded the entire physical address space, therefore it commanded the entire machine. This confused the protection between kernel (because kernel runs in Ring 0) and TCB (because ring 0, therefore kernel, can access all memory). With the introduction of Hypervisor, a new abstraction layer was introduced. Hypervisor didn’t rely on rings, it had its own privileged CPU instructions. But since it brings restrictions to what ring 0 can do, and therefore it is below ring 0, it is nicknamed “ring -1”. Hypervisor is consequently protected from kernel and ring 0. Also, hypervisor is small compared to rest of the system, therefore easier to test and verify. And as mentioned above, it roots its security on HW. Therefore, we can consider hypervisor as true TCB. Hypervisor would be a good place to keep and process secrets, but that would make it bigger and more complex, which is detrimental to its security. It is clear that there is a need for hypervisor kind of isolation without cluttering hypervisor.
Virtual Trust Levels - VTLs
Windows 10 introduces a new concept called Virtual Trust Levels. Historically, access layers grew vertically. VTLs allow growing horizontally. Here is the legacy architecture: